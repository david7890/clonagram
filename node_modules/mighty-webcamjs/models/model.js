import atom from 'atom-js';

module.exports = (Webcam) => {
	const videoParams = {
		video_recording_time: 10, // seconds
		// We assume bitrate 2500000 is OK for 640x480.
		// 640 * 480 * 8.2 ~= 2500000
		// 1280 * 720 * 8.2 ~= 7500000
		// fps should be also counted, but we don't have control over it.
		video_bitrate_per_pixel: 7.5,
		video_length: 2 * 60 * 1000, // 2 minutes to save some bandwith.
	};

	const params = {
		capture_mode: Webcam.constants.CAPTURE_MODE_PHOTO,

		width: 0,
		height: 0,
		dest_width: 2560,      // size of captured image.
		dest_height: 2560,        // these default to width/height

		image_format: 'jpeg',  // image format (may be jpeg or png)
		jpeg_quality: 90,      // jpeg image quality from 0 (worst) to 100 (best)
		enable_flash: true,    // enable flash fallback,
		force_flash: false,    // force flash mode
		force_file: false,     // force file upload mode
		flip_horiz: false,     // flip image horiz (mirror mode)
		flip_horiz_back: undefined,     // flip image horizontally on both: front and back camera
		flip_horiz_on_snap: false,     // flip image horiz when snaped
		fps: 30,               // camera frames per second (used in Flash)
		webcam_path: './',            // URI to webcam.swf movie (defaults to the js location)
		flash_not_detected_text: 'ERROR: No Adobe Flash Player detected. Webcam.js relies on Flash for browsers that do not support getUserMedia (like yours).',
		enable_file_fallback: true,
		force_fresh_photo: false, // When true, it will disallow to Select Photo from Library on iOS
		no_interface_found_text: 'No supported webcam interface found.',
		unfreeze_snap: true,   // Whether to unfreeze the camera after snap (defaults to true)
		camera: Webcam.constants.CAM_BACK,        // "front" or "back"
		cameraDetectionMode: null, // Labels are more reliable than webrtc, but doesn't always work
		switch_camera_node: 'Switch camera',   // Contents of "Switch Camera" button. React Node required
		maximum_blur_index: 0,      // 0 to disable, less is better. Recommended value: 0.8
								    // read more and experiment: https://github.com/CezaryDanielNowak/inspector-bokeh
		verbose: true,              // Set to false to hide logs.
		best_resolution_finder: true, // option that seeks higher resolution after detecting
									  // one of preset one
		use_ImageCapture_API: false,
		flash_light_node: 'Enable Flash Light', // React Node required
		cameraId: undefined,                // For browsers, that does not support facingMode
		cameraInfs: [], // list of Inf objects for atteched camera devices
		...videoParams,
		cameraMode: null,
		userMedia: true, // true when getUserMedia is supported natively;
	};

	// state is cleared after reset (rotate, reattach etc)
	const state = {
		load: false, // true when webcam movie finishes loading
		live: false, // true when webcam is initialized and ready to snap
		videoRecording: false,
		loadedVideoDimensions: {},
		photoCapabilities: {}, // https://developer.mozilla.org/en-US/docs/Web/API/PhotoCapabilities
	};

	const defaults = {
		...params,
		...state
	};

	let initialisation = true;
	const model = atom.setup({
		onChange: (field, value) => {
			!initialisation && Webcam.dispatch(field, value);
		}
	})(defaults);
	initialisation = false;

	model.resetState = () => {
		// clear data marked as state, keep params.
		Object.keys(model.get()).forEach((key) => {
			const isParam = key in params;
			const isDefaultState = key in state;

			isParam || model.set(key, isDefaultState ? state[key] : undefined);
		});
	};

	model.on('use_ImageCapture_API', (value) => {
		if (value && typeof ImageCapture === 'undefined') {
			// eslint-disable-next-line no-console
			console.warn('ImageCapture is not available. `use_ImageCapture_API` passed to webcamjs reset to `false`.');
			model.set('use_ImageCapture_API', false);
		}
	});

	return model;
};
